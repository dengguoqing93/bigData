### Java线程基础

#### 实现方式：

+ 继承Thread类
+ 实现Runnable接口

### Thread的API方法

+ getName() ：获取线程的名称

+ getId() : 获取唯一的标识

+ start() : 异步的方法，该方法通知线程规划器此线程已经准备就绪，等待调用线程对象的run()方法

+ threa.run() : 同步的方法，有main主线程调用run方法，必须等run方法中的代码执行完才能执行后面的代码

  执行start方法的顺序不代表线程启动的顺序

+ this：当前线程

+ currentThread() : 表示承载当前线程的线程？

+ isAlive() : 判断当前线程是否处于活动状态

+ sleep() : 当前线程休眠

+ interrupt()给当前线程标记一个中断状态。不会中断线程。

+  interrupted()判断当前线程是否含被标记中断。执行后讲标记状态清除。

+ isInterrupted()判断当前线程是否被标记中断，但不清除状态标识。

+ stop()立即停止线程。

+ suspend()暂停线程。

+  resume()恢复线程。

+  yield()放弃当前cup资源，将它让给其他任务去占用cpu执行时间。但是时间不确定。

+  setPriority()设置线程的优先级。 1~10级，默认为5 

+ setDaemon(true):守护线程,当进程中不存在用户线程了，则守护线程自动销毁。守护线程创建的线程 也是守护线程。



### 锁原理

#### 1、 为什么使用锁？

​	锁-是为了解决并发操作引起的脏读、数据不一致的问题



#### 2、锁实现的原理

##### 2.1 volatile

